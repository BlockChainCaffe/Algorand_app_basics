# Basic Contract

Basic example of a contract deploy and interaction
This example uses the bare minimum modules, it does not use the whole
`algokit init` to keep the project as simple as possible.

It's far more hands-on and lets you do things one by one. It also has,  a negligible data footprint:
- an `algokit init` project coul easily be more than 60Mb
- this approach requires a few hundreds kb...

Credits: Leo Costa (https://www.youtube.com/watch?v=SJrR47eho7Y)

## Dependencies

``` bash
pip install py-algorand-sdk
pip install algokit
pip install algorand-python
```

## Notes and general description
The programs here are an example of how you can create, run, test and deploy an Algorand smart-contract with python.
The different programs use a shelve database file `shelve.db` to store and share values (addresses, keys etc). It basically replaces a `.env` file

## Programs and files

Programs:

- **contract.py**: simple helloword contract
- **generate_account.py**: generates an account (private key and address) and stores it in the shelve db for other programs
- **set_network.py**: lets you choose where to deploy the contract (localnet, testne, mainnet) and stores the parameters in the shelve db
- **helpers.py**: some python functions you can play with
- **shelview.py**: prints all key:values in the shelves db
- **clean.py**: tool to remove entries from `shelve.db`
- **deploy.py**: deploy program (you don't say!). Gets data from shelve db and uses it with the files to deploy the contract in the selected network with the selected account
- **interact.py**: an application that interacts with the application using the compiled client


Generated files:
- `shelve.db` is a local key/value pair db used to pass parameters and values between the differen programs.
- all the `HelloWorldContract.*` files are generated by the compliler


## How to use these tools


### Step1: edit and compile
1. revew / Edit the contract.py file

``` python
from algopy import (
    ARC4Contract,
    String
)
from algopy.arc4 import abimethod

class HelloWorldContract(ARC4Contract):

    @abimethod
    def hello(self, name: String) -> String:
        return "Hello, "+name
```

2. compile the contract using `algokit compile` requesting an ARC56 extended ABI output

```
❯ algokit compile python contract.py --output-arc56
info: Writing HelloWorldContract.arc56.json
info: Writing HelloWorldContract.approval.teal
info: Writing HelloWorldContract.clear.teal
info: Writing HelloWorldContract.approval.puya.map
info: Writing HelloWorldContract.clear.puya.map
```

3. You will obtain the following files:
- HelloWorldContract.arc\*.json : extended contract ABI files in arc32 and 56 format
- HelloWorldContract.\*.teal: teal intermediary artifacts
- HelloWorldContract.\*.puya.map: puya map intermediary artifacts

Also `*.approval.*` and `*.clear.*` files refer to the approval and clear state code for the contract where:
- **approval** contract is the main contract that implements all the logic
- **clear** contract is the code that the user executes when opting-out of a contract

4. Generate the client

```
❯ algokitgen-py -a HelloWorldContract.arc56.json -o HelloWorldContract_client.py
```
or
```
❯ algokit generate client ./HelloWorldContract.arc56.json --output HelloWorldContract_client.py
```

This will output the `HelloWorldContract_client.py` file that contains a set of classes needed to interact with the contract

> **Notice**: 
>The client module must end with **_client.py** and not .client.py
> otherwhise it is not a valid module name and interact.py can't import it

<br/>

### Step2: Pick a network
Your app/smart-contract will end up in some network. Use the `set_network.py` program to pick between localnet, testnet or main net. The program simply writes the parameters of the network you choose to `shelve.db` for later use.

You can later use the `shelview.py` program to dump the contents of shelve.db to retrieve these values.

If you need to start the local network use:
```
sudo algokit localnet start/status/...
```

<br/>

### Step3: create an account
Use the `generate_account.py` program to generate a new private key and address pair. They will be saved on the shelves db so you don't need to write them down or anything.
If you previously already defined an account and re-run the `generate_account.py` program, that account will be overwritten and lost. To prevent this from happening the program requests a confirmation before proceeding.

Once done the private key and address will be registered in `shelve.db` and printend.

You can later use the `shelview.py` program to dump the contents of shelve.db to retrieve these values.
<br/>

### Step4: Fund the user account

The account you created in step 3 needs to be empty to operate and meet the MBR requirements.
Depending on the network you have different options to get some algo in the account balance

For **Localnet**: 
- navigate to https://lora.algokit.io/localnet/fund  
- paste the address of your wallet
- select an amount

For **Testnet**:
- navigate to https://bank.testnet.algorand.network/
- paste the address of your wallet
- go to https://lora.algokit.io/testnet/ and check the transaction outcome

For **Mainnet**:
- buy some algos at Conio.com

Once you funded the account, use LORA set to the corresponding network to check the balance of the account.

<br/>

### Step5: Deploy
This step deploys the contract to the selected network using the parameters stored in the `shelves.db`. 

Run the `deploy.py` program.
Unless some error occurs the app will be deployed and you'll get:
- application ID
- application account address
- deploy transaction ID
- link to inspect the deployed contract in Lora explorer

The deploy.py script will also fund the application account and show the results and some details of the transactions involved. You can then see the transactions using LORA.

<br/>

### Step6: Basic Interaction

> **NOTICE**
> The interact.py script can only interact with the HelloWorld contract
> See step 7 for a broather example

It's time to interact with the contract you deployed !!
Make sure you have the file `HelloWorldContract_client.py` created in step 4, because `interact.py` will get the needed classes and methods from it
The program will perform the following actions in this order:
1. get data from `shelve.db` 
1.1 check it for completeness and consistency
1.2 include the `HelloWorldContract_client.py`
1.3 include the arc56.json extended ABI
<br>
2. connect to the chosen algorand network
2.1 creates an algod client to interact with the node
2.2 creates a algorand client to interact with the algorand blockchain

<br>
3. inspects the contract (looking at the ABI) 
3.1 check all methods available
3.2 print inputs and output of the method

<br>
4. connect to the contract
4.1 gets an application client via the algorand client
4.2 creates a signing account inside the algorand client that can sign the transactions
4.3 creates a transaction to call one application method

<br/>
5. prints the results 

You can inspect and play with the code

<br/>

### Step7: Advanced Interaction
The `interactive.py` script is more flexible than the one used in the previous step. It creates an interactive TUI that allows to send transactions to the smart contract.
It will start by connecting to a **deployed** instance of the contract, then propose a list of available methods to call

To call a method simply use the format:

```
> METHOD_NAME PARAM1 PARAM2...
```

The result of the transaction will be printed out so that you can inspect it in LORA.