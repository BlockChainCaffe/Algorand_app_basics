# Basic Contract

Basic example of a contract deploy and interaction
This example uses the bare minimum modules, it does not use the whole
`algokit init` to keep the project as simple as possible.

It's far more hands-on and lets you do things one by one. It also has,  a negligible data footprint:
- an `algokit init` project coul easily be more than 60Mb
- this approach requires a few hundreds kb...

Credits: Leo Costa (https://www.youtube.com/watch?v=SJrR47eho7Y)

## Dependencies

``` bash
pip install py-algorand-sdk
pip install algokit
pip install algorand-python
```

## Notes and general description
The programs here are an example of how you can create, run, test and deploy an Algorand smart-contract with python.
The different programs use a shelve database file `shelve.db` to store and share values (addresses, keys etc). It basically replaces a `.env` file

## Programs and files

Programs:

- **contract.py**: simple helloword contract
- **generate_account.py**: generates an account (private key and address) and stores it in the shelve db for other programs
- **set_network.py**: lets you choose where to deploy the contract (localnet, testne, mainnet) and stores the parameters in the shelve db
- **helpers.py**: some python functions you can play with
- **shelview.py**: prints all key:values in the shelves db
- **clean.py**: tool to remove entries from `shelve.db`
- **deploy.py**: deploy program (you don't say!). Gets data from shelve db and uses it with the files to deploy the contract in the selected network with the selected account
- **interact.py**: an application that interacts with the application using the compiled client
- **test_template.py**: a test template to ease integration testing on localnet/testnet


Generated files:
- `shelve.db` is a local key/value pair db used to pass parameters and values between the differen programs.
- all the `HelloWorldContract.*` files are generated by the compliler


## How to use these tools


### Step1: edit and compile
1. revew / Edit the contract.py file

``` python
from algopy import (
    ARC4Contract,
    String
)
from algopy.arc4 import abimethod

class HelloWorldContract(ARC4Contract):

    @abimethod
    def hello(self, name: String) -> String:
        return "Hello, "+name
```

2. compile the contract using the `compile.sh` script 

```
❯ compile.py contract.py
```

3. You will obtain the following files:
- HelloWorldContract.arc\*.json : extended contract ABI files in arc32 and 56 format
- HelloWorldContract.\*.teal: teal intermediary artifacts
- HelloWorldContract.\*.puya.map: puya map intermediary artifacts
- HelloWorldContract_client.py: python client classes

Also `*.approval.*` and `*.clear.*` files refer to the approval and clear state code for the contract where:
- **approval** contract is the main contract that implements all the logic
- **clear** contract is the code that the user executes when opting-out of a contract

> **Notice**: 
>The client module must end with **_client.py** and not .client.py
> otherwhise it is not a valid module name and interact.py can't import it

<br/>

### Step2: Pick a network
Your app/smart-contract will end up in some network. Use the `set_network.py` program to pick between localnet, testnet or main net. The program simply writes the parameters of the network you choose to `shelve.db` for later use.

You can later use the `shelview.py` program to dump the contents of shelve.db to retrieve these values.

If you need to start the local network use:
```
sudo algokit localnet start/status/...
```

<br/>

### Step3: create an account
Use the `generate_account.py` program to generate a new private key and address pair. They will be saved on the shelves db so you don't need to write them down or anything.
If you previously already defined an account and re-run the `generate_account.py` program, that account will be overwritten and lost. To prevent this from happening the program requests a confirmation before proceeding.

Once done the private key and address will be registered in `shelve.db` and printend.

You can later use the `shelview.py` program to dump the contents of shelve.db to retrieve these values.
<br/>

### Step4: Fund the user account

The account you created in step 3 needs to be empty to operate and meet the MBR requirements.
Depending on the network you have different options to get some algo in the account balance

For **Localnet**: 
- navigate to https://lora.algokit.io/localnet/fund  
- paste the address of your wallet
- select an amount

For **Testnet**:
- navigate to https://bank.testnet.algorand.network/
- paste the address of your wallet
- go to https://lora.algokit.io/testnet/ and check the transaction outcome

For **Mainnet**:
- buy some algos at Conio.com

Once you funded the account, use LORA set to the corresponding network to check the balance of the account.

<br/>

### Step5: Deploy
This step deploys the contract to the selected network using the parameters stored in the `shelves.db`. 

Run the `deploy.py` program.
Unless some error occurs the app will be deployed and you'll get:
- application ID
- application account address
- deploy transaction ID
- link to inspect the deployed contract in Lora explorer

The deploy.py script will also fund the application account and show the results and some details of the transactions involved. You can then see the transactions using LORA.

<br/>

### Step6: Basic Interaction

> **NOTICE**
> The interact.py script can only interact with the HelloWorld contract
> See step 7 for a broather example

It's time to interact with the contract you deployed !!
Make sure you have the file `HelloWorldContract_client.py` created in step 4, because `interact.py` will get the needed classes and methods from it
The program will perform the following actions in this order:
1. get data from `shelve.db` 
1.1 check it for completeness and consistency
1.2 include the `HelloWorldContract_client.py`
1.3 include the arc56.json extended ABI
<br>
2. connect to the chosen algorand network
2.1 creates an algod client to interact with the node
2.2 creates a algorand client to interact with the algorand blockchain
<br>
3. inspects the contract (looking at the ABI) 
3.1 check all methods available
3.2 print inputs and output of the method
<br>
4. connect to the contract
4.1 gets an application client via the algorand client
4.2 creates a signing account inside the algorand client that can sign the transactions
4.3 creates a transaction to call one application method
<br/>
5. prints the results 

You can inspect and play with the code

<br/>

### Step7: Advanced Interaction
The `interactive.py` script is more flexible than the one used in the previous step. It creates an interactive CLI that allows to send transactions to the smart contract and more.
It will start by connecting to the selected network and a **deployed** instance of the contract.

A panel with be shown with the folowing info separated by horizontal lines:
1) network and account info:
    - used network and endpoint
    - used account address and private key
    - account balance and MBR
    - apps the account has created
    - apps the account has opted in
        - for each of those the local storage key:values are displayed
2) the contract it is connected to
    - contract name as per the ABI, app id and app account address
        - box storage: each box key and content (bytes)
        - global storage (glb): each key and value
        - local storage (lcl) of the user's account: each key and value
    - the contract ARC4 methods where for each method is shown:
        - required input parameters and return type
        - list of on_completion possible values [1..6]
        - a list of create parameters
3) Generic transactions
    - just payments at the moment
4) Additional transaction parameters
    - on_complete: add `on_compelte:0` ... `on_complete:5` to add this feature the the transaction. This is usefull to opt-in using a method that has `[oc=1]`

Example: 

```
🚀 Using net:         http://localhost:4001     Token: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
🔑 Using address:     N2BM7FMNFGZACFDRGYODAVSLVLJVSGT3T7M3Q37QWRJKKGHJGGNDEU7TRM
   Using private key: U28djzPz2JGyxCeLMbrMBHsF6M805NleYepQRfR+E3Jugs+VjSmyARRxNhwwVkuq01kae5/ZuG/wtFKlGOkxmg==
💰 Account balance    244.933 algos     (MBR: 0.614 algos)
🔧 Apps created       [1003, 1036]
👍 Apps opted in:
                      1003 : st_local = {'bytes': '', 'type': 2, 'uint': 9876}
                      1036 : st_local = {'bytes': '', 'type': 2, 'uint': 90987}
___________________________________________________________________________________________________
🔵 Using contract:    "Storage" (app id: 1036, app address: OPRKZ57H6B4OFHNUMFBH5ML77PH2XEVXTGI6I6VCIUE5FV3PRDHN4L7UH4)
  🔹                  box st_box: b'\x00\x00\x00\x00\x00\x00\x00\x01'
  🔹                  gbl st_global: 0
  🔹                  lcl st_local: 90987
🟦 Contract methods:
  🔹 set_b (uint64:data) -> uint64
  🔹 set_g (uint64:data) -> uint64
  🔹 set_l (uint64:data) -> uint64
  🔹 get_b () -> uint64
  🔹 get_g () -> uint64
  🔹 get_l () -> uint64
  🔹 get_version () -> uint64   [oc=1]
___________________________________________________________________________________________________
🟦 Generic tx:
  🔹 payment (receiver:address, amount:uint64) -> uint64
___________________________________________________________________________________________________
🟦 Txn Parameters
  🔹 on_complete:<NoOp=0/OptIn/CloseOut/Clearstate/UpdateApplication/DeleteApplication=5>

Insert name of method and parameters to send application call
[Q] to exit
```

In this example you could type different commands:

1) **Opt-in to the contract**: you need to use the get_version method because it's the only method that has `[oc=1]` in the list

```
get_version on_complete:1
```

2) Call **get methods**: all the get_* methods have no parameters, so unless you need to add some `on_complete` extra params, just type the name of the method like:
```
get_b
```

3) Call **set methods**: the set_* methods accept a UInt64 parameter, so we need to add it like:
```
set_b 999
```

if the method requires more parameters in the call just add them separated by spaces


### Step8: Integration testing
`test_template.py` is a generic **pytest** template for tests

Since algopy_testing module simply simulate the AVM and **does not** allow you to test all transaction possible uses, you need to test the contract in a complete lagorand setup (localnet, testnet).

This template relies on the fact that the contract/app was deployed using applications in steps 1 through 5 of this set and that the right values of the app to be tested are in the shelve.db file.

#### Test setup

The first 400 lines or so take care of importing the values of `shalve.db` in a SharedState object that will be used by the fixtures and the tests and implements some helper functions

For your convenience some funcitons are provided:
- `application_call`: helps you submitting a transaction. You need to pass it the SharedState object, name of the method, optional method parameters, optional transaction parameters (on_complete etc). Use this function to interact with the contract.
- `dump_state` : dumps the SharedState. You can provide an extra key parameter if you want to dump just that key
- `new_signer` : adds a new signer (user account) to the SharedState and optionally funds it using funds from the main address (defined by `generate_account.py`). The new signer is given a name and can later be used to send transactions via `application_call`
- `signer_balance`  : returns the balance (in microalgos) of a signer. The signer is identified by the account name and must have been previously created with `new_signer`
- `fund_signer` : gives some funds to the previously created signer

#### Running your own tests

You can write your own tests as you would normally do for pytest. 
Copy this file and modify the copy and add your custom tests there. All thest should be in the form

``` python
def test_something(shared_state):  ## You may add more fixtures if you need
    ## Prepare the test
    ## Interact with the SC
    ## Chekc results
    assert True == True
```

Then run it  with:
```
pytest -v -s test_XXX.py
```